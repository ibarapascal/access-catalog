# Typescript (javascript) summary  

## Index  

- [capitalization](#capitalization)  
- [bracket notation and dot notation](#bracket-notation-and-dot-notation)
- [const data in ts](#const-data-in-typescript)  
- [js-array](#js-array)  
- [js-object](#js-object)  
- [shallow-copy-and-deep-copy](#shallow-copy-and-deep-copy)

### capitalization

In general, use:  
>functionNamesLikeThis  
variableNamesLikeThis  
ClassNamesLikeThis  
EnumNamesLikeThis  
methodNamesLikeThis  
SYMBOLIC_CONSTANTS_LIKE_THIS  

refer to [QA](https://stackoverflow.com/questions/1540763/capitalization-convention-for-javascript-objects)  

### bracket-notation-and-dot-notation

Refer to [QA](https://stackoverflow.com/questions/4255472/javascript-object-access-variable-property-by-name-as-string)

```tsx
type YourType = {
  a: string;
  b: string;
}
const item: YourType = {
  a: 'valueA',
  b: 'valueB',
};
// dot-notation, ok in normal way
console.log(item.a);
// brackt-notition, for reactive implements, not well defined in typescript
console.log(item['a']); // Error: No index signature with a parameter of type 'string' was found on type 'YourType'.
// You may pass it via `any`
console.log((item as any)['a']);
```

If we want to specific type definition in bracket-notation, we may need some implements kind of like below.  

### const-data-in-ts  

What we want to do: generate type definition from single source constant  

Practice example:  

```tsx
export class Constant {
  /**
   * Single data source
   */
  static readonly A = [
    {id: '1', name: 'Estimator', attr: 'estimator', ...},
  ] as const;
  static readonly B = [
    {id: '1', name: '配分', attr: 'distribute', ...},
    {id: '2', name: '金額', attr: 'cost', ...},
    {id: '3', name: 'マークアップ率', attr: 'markupRate', ... }
  ] as const;
  // ...
  static readonly TOTAL = [
    ...Constant.A,
    ...Constant.B,
    // ...
  ] as const;

  /**
   * Get part of above data via attributes
   */
  static readonly INPUT_ATTR_LIST = [
    'estimator',
    'cost',
  ] as const;
  static readonly TOTAL = ProcessService.obtainSubList(
    Constant.TOTAL,
    Constant.INPUT_ATTR_LIST
  );
}

/**
 * Export type definition generated by data above
 */
const totalList = Const.TOTAL.map(x => x.attr);
export type DATA_SIMULATION_TABLE_LIST = typeof totalList[number]; // 'estimator' | 'distribute' | 'cost' | 'markupRate'
const inputList = Const.INPUT_ATTR_LIST;
export type P5_INPUT_ATTR_LIST = typeof inputList[number]; // 'estimator' | 'cost'
```

And the related `ProcessService` methods

```tsx
export default class ProcessService {
  /**
   * Get position index number list for each attribute
   * @param baseList check base list
   * @param attrList check items list
   */
  static obtainIdxList(baseList: readonly any[], attrList: readonly string[]): Array<number> {
    return Array.from(Array(attrList.length).keys()).map((v, idx) =>
      baseList.findIndex((x: {attr: string}) => x.attr === attrList[idx])
    );
  }
  /**
   * Get sub list for each attribute
   * @param baseList check base list
   * @param attrList check items list
   */
  static obtainSubList<T>(baseList: readonly T[], attrList: readonly string[]): Array<T> {
    return baseList.filter((v, idx) =>
      this.obtainIdxList(baseList, attrList).includes(idx)
    );
  }
  // ...
}
```

### js-array  

In specific practice  

- Remove duplicated value in array  
- If have, update, else add  
- If have, delete, else add  
- Generate init array with 0, 0, 0 and 1, 2, 3  
- Compare two array  

### js-obejct  

In specific practice  

- Add an attribute to current existing obejct  
- Compare two object  

## shallow-copy-and-deep-copy

In specific practice with redux and without immutable  
